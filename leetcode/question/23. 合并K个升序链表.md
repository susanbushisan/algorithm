给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

示例 1：

    输入：lists = [[1,4,5],[1,3,4],[2,6]]
    输出：[1,1,2,3,4,4,5,6]
    解释：链表数组如下：
    [
      1->4->5,
      1->3->4,
      2->6
    ]
    将它们合并到一个有序链表中得到。
    1->1->2->3->4->4->5->6
示例 2：

    输入：lists = []
    输出：[]
示例 3：

    输入：lists = [[]]
    输出：[]
 

提示：

- k == lists.length
- 0 <= k <= 10^4
- 0 <= lists[i].length <= 500
- -10^4 <= lists[i][j] <= 10^4
- lists[i] 按 升序 排列
- lists[i].length 的总和不超过 10^4

思考

    简单且粗暴，拿到所有链表，然后判断本身元素，找到最小的构成结构，然后该条链表向后移动，结果通过了，但是时间复杂度很不理想时间复杂度为O（k*N^2）
    
    那么暴力的来了，将链表所有元素放到一个list中，然后排序，最后生成结果，还可以
    
    参考了下别人的答案，有将两个链表递归再循环调用，和方法一的进一步处理，使用最小堆（小根堆）优化找到最小头元素方法，可以将时间复杂度降到O(kN *logk)
    
具体实现：/src/Question23.mergeKLists
具体实现：/src/Question23.mergeKListsSlow
具体实现：/src/Question23.mergeKListsRight